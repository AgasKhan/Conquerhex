// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Alphas
#pragma kernel Details
#pragma kernel Paths

#include "Assets/VFX/Shaders/ShaderGraph Funcs.hlsl"
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
//RWTexture2D<float4> Result;

RWStructuredBuffer<int> inputPathBuffer;

RWStructuredBuffer<float4> outputAlphaBuffer;

RWStructuredBuffer<int> outputDetailsBuffer;

RWStructuredBuffer<int2> inputVertex;

float3 toSave;

uint pathEntry;

uint width;

uint height;

uint detailResolution;

float scale;

float rng;

float diference;



/////////////////////////////////////////////////////////

float2 unity_gradientNoise_dir(float2 p)
{
    p = p % 289;
    float x = (34 * p.x + 1) * p.x % 289 + p.y;
    x = (34 * x + 1) * x % 289;
    x = frac(x / 41) * 2 - 1;
    return normalize(float2(x - floor(x + 0.5), abs(x) - 0.5));
}

float unity_gradientNoise(float2 p)
{
    float2 ip = floor(p);
    float2 fp = frac(p);
    float d00 = dot(unity_gradientNoise_dir(ip), fp);
    float d01 = dot(unity_gradientNoise_dir(ip + float2(0, 1)), fp - float2(0, 1));
    float d10 = dot(unity_gradientNoise_dir(ip + float2(1, 0)), fp - float2(1, 0));
    float d11 = dot(unity_gradientNoise_dir(ip + float2(1, 1)), fp - float2(1, 1));
    fp = fp * fp * fp * (fp * (fp * 6 - 15) + 10);
    return lerp(lerp(d00, d01, fp.y), lerp(d10, d11, fp.y), fp.x);
}

void Unity_GradientNoise_float(float2 UV, float Scale, out float Out)
{
    Out = unity_gradientNoise(UV * Scale) + 0.5;
}

/////////////////////////////////////////////////////////

inline float2 unity_voronoi_noise_randomVector(float2 UV, float offset)
{
    float2x2 m = float2x2(15.27, 47.63, 99.41, 89.98);
    UV = frac(sin(mul(UV, m)) * 46839.32);
    return float2(sin(UV.y * +offset) * 0.5 + 0.5, cos(UV.x * offset) * 0.5 + 0.5);
}

void Unity_Voronoi_float(float2 UV, float AngleOffset, float CellDensity, out float Out, out float Cells)
{
    float2 g = floor(UV * CellDensity);
    float2 f = frac(UV * CellDensity);
    float t = 8.0;
    float3 res = float3(8.0, 0.0, 0.0);

    for (int y = -1; y <= 1; y++)
    {
        for (int x = -1; x <= 1; x++)
        {
            float2 lattice = float2(x, y);
            float2 offset = unity_voronoi_noise_randomVector(lattice + g, AngleOffset);
            float d = distance(lattice + offset, f);
            if (d < res.x)
            {
                res = float3(d, offset.x, offset.y);
                Out = res.x;
                Cells = res.y;
            }
        }
    }
}

/////////////////////////////////////////////////////////

int IndexForIdAlpha(uint3 id)
{
    return id.x + (id.y * width);
}

int IndexForIdDetails(uint3 id)
{
    return id.x + (id.y * detailResolution);
}

uint IndexPath(uint i)
{
    return pathEntry + i > 5 ? pathEntry + i - 6 : pathEntry + i;
}

float2 UVCalc(uint x, uint y)
{
    if (x > uint(width - 1))
    {
        y++;
    }
    
    if (y > uint(height - 1))
    {
        return float2(0, 0);
    }
    
    return float2(float(x) / width, float(y) / height) + rng;
}


///////////////////////////////////////////////////////////

bool IsRayIntersecting(int2 p, int2 edge1, int2 edge2)
{
    if (edge1.y > edge2.y)
    {
        int2 temp = edge1;
        edge1 = edge2;
        edge2 = temp;
    }

    if (p.y == edge1.y || p.y == edge2.y)
    {
        p.y += 1; // Adjust for horizontal ray case
    }

    if (p.y > edge2.y || p.y < edge1.y || p.x > max(edge1.x, edge2.x))
    {
        return false; // No intersection
    }

    if (p.x < min(edge1.x, edge2.x))
    {
        return true; // Ray intersects segment
    }

    float intersectX = float(p.y - edge1.y) * float(edge2.x - edge1.x) / float(edge2.y - edge1.y) + edge1.x;
    return p.x < intersectX;
}

bool IsPointInHexagon(int2 p)
{
    uint intersections = 0;
    const uint vertexCount = 6;

    // Ray-casting algorithm
    for (uint i = 0; i < vertexCount; i++)
    {
        uint j = (i + 1) % vertexCount;
        
        int2 I = (normalize(inputVertex[i] - int2(width / 2, height / 2)) * width/2 + int2(width / 2, height / 2));
        
        int2 J = (normalize(inputVertex[j] - int2(width / 2, height / 2)) * width/2 + int2(width / 2, height / 2));
        
        if (IsRayIntersecting(p, I, J))
        {
            intersections++;
        }
    }

    return (intersections % 2 != 0);
}
//////////////////////////////////////////////////////////

[numthreads(8, 8, 1)]
void Paths(uint3 id : SV_DispatchThreadID)
{
    if (id.x > width - 1 || id.y > height - 1)
        return;
    
    float resultado;
    
    float Out = 0;
    
    uint lenght;
    uint stride;
    inputPathBuffer.GetDimensions(lenght, stride);
    
    int localBuffer[6];
    
    for (uint i = 0; i < lenght; i++)
    {
        localBuffer[i] = inputPathBuffer[i];
    }
    
    float2 start = float2(0,0);
    float2 end;
    float2 startEnd;
    
    for (i = 0; i < lenght; i++)
    {
        if (localBuffer[(i)] == 1)
        {
            if (start.x == 0)
            {
                start = float2(float(inputVertex[(i)].y) / width, float(inputVertex[(i)].x) / height);
                startEnd = start;
            }
            else
            {
                start = float2(float(inputVertex[(i)].y) / width, float(inputVertex[(i)].x) / height);
            }
            
            for (uint j = 0; j < lenght; j++)
            {
                if (localBuffer[(j)] == 1)
                {
                    
                    end = float2(float(inputVertex[(j)].y) / width, float(inputVertex[(j)].x) / height);
                    
                    Bezier2_float(id.xy / float(width), start,0.3, end, diference, resultado);
                    
                    //LinealPoint_float(id.xy / float(width), start, end, diference, resultado);
                    
                    Out += resultado;
                    
                    localBuffer[(j)] = 0;
                    
                    start = end;
                }
            }
        }
    }
    
    Bezier2_float(id.xy / float(width), end, 0.3, startEnd, diference, resultado);
    //LinealPoint_float(id.xy / float(width), end, startEnd, diference, resultado);
    Out += resultado;
    
    float4 aux = outputAlphaBuffer[IndexForIdAlpha(id)];
    
    Out =  clamp(Out, 0, 1);
    
    aux.x = clamp(aux.x - Out, 0, 1);
    
    aux.y = clamp((aux.y - Out), 0, 1);
    
    aux.w = clamp((aux.w - Out), 0, 1);
    
    aux.z = clamp((Out + aux.z), 0, 1);
    
    outputAlphaBuffer[IndexForIdAlpha(id)] = aux;
}


[numthreads(8, 8, 1)]
void Details(uint3 id : SV_DispatchThreadID)
{
    if (id.x > detailResolution - 1 || id.y > detailResolution - 1)
        return;
    
    float aux;
    float Out;
    
    uint2 index = uint2((id.x+1) * width / detailResolution, (id.y+1) * height / detailResolution);
    
    uint2 indexEnd = index + (width / detailResolution)*0.75;
    
    uint2 indexStart = index - (width / detailResolution)*0.75;
    
    uint indexBuffer = index.x + index.y * width;
    
                
    if ((outputAlphaBuffer[indexBuffer].z == 0 && outputAlphaBuffer[indexBuffer].x == 0 && outputAlphaBuffer[indexBuffer].y == 0 && outputAlphaBuffer[indexBuffer].w == 0))
    {
        outputDetailsBuffer[IndexForIdDetails(id)] = 0;
        return;
    }
    
    uint4 punto = outputAlphaBuffer[indexBuffer];    
    
    uint4 cercanias = uint4(0, 0, 0, 0);
 
    for (index.x = indexStart.x; index.x < indexEnd.x; index.x++)
    {
        for (index.y = indexStart.y; index.y < indexEnd.y; index.y++)
        {       
            if (index.x >= 0 && index.x < width && index.y >= 0 && index.y < height)
            {
                indexBuffer = index.x + index.y * width;
                
                if ((outputAlphaBuffer[indexBuffer].z == 0 && outputAlphaBuffer[indexBuffer].x == 0 && outputAlphaBuffer[indexBuffer].y == 0))
                {
                    outputDetailsBuffer[IndexForIdDetails(id)] = 0;
                    return;
                }
                
                if (outputAlphaBuffer[indexBuffer].x == 1)
                {
                    cercanias.x = 1;
                }

                if (outputAlphaBuffer[indexBuffer].y == 1)
                {
                    cercanias.y = 1;
                }
                
                if (outputAlphaBuffer[indexBuffer].z == 1)
                {
                    cercanias.z = 1;
                }
                
                if (outputAlphaBuffer[indexBuffer].w == 1)
                {
                    cercanias.w = 1;
                }
            }
        }
    }
    
    if (punto.x == 1 && cercanias.y != 1 && cercanias.z != 1 && cercanias.w != 1)
    {
        outputDetailsBuffer[IndexForIdDetails(id)] = 1;
    }
    else if (punto.y == 1 && cercanias.x != 1 && cercanias.z != 1 && cercanias.w != 1)
    {
        outputDetailsBuffer[IndexForIdDetails(id)] = 2;
    }
    else if (punto.z == 1 && cercanias.w != 1)
    {
        outputDetailsBuffer[IndexForIdDetails(id)] = 3;
    }
    else
    {
        outputDetailsBuffer[IndexForIdDetails(id)] = 0;
    }
}

[numthreads(8,8,1)]
void Alphas(uint3 id : SV_DispatchThreadID)
{
    if (id.x > width - 1 || id.y > height - 1 || !IsPointInHexagon(id.xy))
        return;
    
    float aux = 0;
    float3 color;
    float Out;
    
    
    //Unity_Voronoi_float(UVCalc(id.x, id.y), 10, scale, Out, aux);
    
    Unity_GradientNoise_float(UVCalc(id.x, id.y), scale, aux);
    
    aux = step(0.6, aux);
    
    outputAlphaBuffer[IndexForIdAlpha(id)] = float4(1 - aux, aux, 0, 0);
}